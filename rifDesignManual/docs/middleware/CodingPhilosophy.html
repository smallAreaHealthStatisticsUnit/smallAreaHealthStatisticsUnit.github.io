<head>
<title>
Coding Philosophy
</title>

<meta 
	name="author" 
	lang="en" 
	content="Kevin Garwood">
<meta 
	name="keywords" 
	lang="en" 
	content="Rapid Inquiry Facility, RIF, environmental health, Kevin Garwood, Java">
	
<link rel="stylesheet" href="../rifDesignManual.css" type="text/css">
</head>

<body>


<header>
<!-- Top Banner -->


<table bgcolor="#B9CDE5">

<tr>
<td width="1000">
<img src="../img/RIFMainBanner.jpg">
</td>
</tr>

<tr>
<td width="1000">

<script src="../lib/jquery-2.1.4.min.js" type="text/javascript"></script>


<script type="text/javascript">
var timeout         = 500;
var closetimer		= 0;
var ddmenuitem      = 0;

function rif_open()
{	rif_canceltimer();
	rif_close();
	ddmenuitem = $(this).find('ul').eq(0).css('visibility', 'visible');}

function rif_close()
{	if(ddmenuitem) ddmenuitem.css('visibility', 'hidden');}

function rif_timer()
{	closetimer = window.setTimeout(rif_close, timeout);}

function rif_canceltimer()
{	if(closetimer)
	{	window.clearTimeout(closetimer);
		closetimer = null;}}

$(document).ready(function()
{	$('#rif > li').bind('mouseover', rif_open);
	$('#rif > li').bind('mouseout',  rif_timer);});

document.onclick = rif_close;
</script>

<ul id="rif">
	<li>
		<a href="../index.html">Project Background</a>
	</li>
	<li>
		<a href="../tools/Tools.html">Tool Suite</a>
	</li>
	<li>
		<a href="../general_architecture/GeneralArchitecture.html">General Architecture</a>
	</li>
	<li>
		<a href="../front_ends/FrontEnds.html">Front Ends</a>
	</li>
	<li>
		<a href="../Middleware.html">Middleware</a>
	</li>		
	<li><a href="../back_ends/BackEnds.html">Back Ends</a>
	</li>
	<li><a href="../about_us/AboutUs.html">About Us</a>
	</li>
</ul>

<div class="clear"> </div>
<br>

</td>
</tr>
</table>

</header>

<nav id="sideBarNavigationLinks">
<!-- Left Side Bar -->

<a href="./CodingPhilosophy.html">Coding Philosophy</a>
<br>
<a href="./SummaryOfDesignDecisions.html">Summary of Design Decisions</a>
<br>
<a href="./GeneralArchitecture.html">General Architecture</a>
<ul>
<li>
	<a href="./PresentationLayer.html">Presentation Layer</a>
</li>
<li>
	<a href="./BusinessConceptLayer.html">Business Concept layer</a>
</li>
<li>
	<a href="./DataStorageLayer.html">Data Storage Layer</a>
</li>
</ul>

<a href="./WebServices.html">Web Services</a>
<br>
<a href="./FileFormats.html">Support for File Formats</a>
<br>
<b>Design Aspects</b>
	<ul>
	<li>
		<a href="./DesigningForSecurity.html">Security</a>
	</li>
	<li>
		<a href="./DesigningForConcurrency.html">Concurrency</a>
	</li>
	<li>
		<a href="./DesigningForTestability.html">Testability</a>
	</li>
	<li>
		<a href="./DesigningForValidation.html">Validation</a>
	</li>
	<li>
		<a href="./DesigningForMaintenance.html">Maintenance</a>
	</li>
	<li>
		<a href="./ErrorHandling.html">Error Handling</a>
	</li>
	</ul>

<a href="./CodeRoadMap.html">Code Road Map</a>
<br>
<a href="./CodingConventions.html">Coding Conventions</a>

</nav>

<section>
<!-- Main Content Area -->


<h1>Coding Philosophy</h1>
<p>
<i>
by <a href="mailto:kgarwood@users.sourceforge.net">Kevin Garwood</a>
</i>
</p>

All RIF coding activities are driven by the following coding philosophy, which is common in 
many development projects:
<ul>
<li>
Get it working using the first or most common way of doing it
</li>
<li>
Get it working for other developers, with the aim of de-skilling future development
</li>
<li>
Get it working with better performance, and only when needed
</li>
</ul>

<p>
Although the philosophy may appear obvious to many, it is worth stating in order to make 
development priorities 

clear.  

<h2>
Coding Philosophy Step 1: Get it working
</h2>
<p>
Getting code working involves writing it in the first way of providing a solution which seems 
intuitive.  This approach is necessary because of the large amount of code that needs to be 
written to support complex requirements of working with environmental health studies.  At this 
point, a solution that is intuitive to one developer may not be intuitive to another.  Furthermore, 
the intuitive solution may prove to be inefficient in some way.  With so many coding features 
recurring within the same project or across many projects, common patterns emerge which become well 
scrutinised by the broader developer community.
</p>

<p>
Ideally we would use design patterns wherever possible so that other developers who recognise the 
design motifs can quickly learn what a piece of code does.  By making references to design patterns, 
the development team can refer other developers to other literature which explains how and why a 
design pattern performs well for a particular context.  However, matching a common code need with 
a standard pattern implementation and then fitting it into the existing code base can be time 
consuming.  The potential benefit of readability here may not justify the work needed to 
standardise a code fragment.  As well, overuse of design patterns can create a case of a tool 
that is looking for an application.


<h2>
Coding Philosophy Step 2: Get it working for other developers
</h2>
<p>
Although this project has been better funded than many other scientific software projects, we recognise 
that its character of future development will likely follow the way most tools are developed in an 
academic setting.  Its long term maintenance will likely be characterised by a series of lone developers 
who code on projects that fund research, not development.
</p>

<p>  
The amount of money available to fund developers will likely remain below market value of seasoned 
commercial developers and it is likely the future development team will comprise mainly graduate 
students who may end up doing some other projects.  It is also possible that future developers may not 
have years of experience developing large code bases in general.
</p>

<p>
It takes skill to design software so that its future maintenance can be de-skilled.  De-skilling future 
development can be done in many ways, but one good way is to use an easily understandable architecture 
which provides the scaffolding needed to add future enhancements.  De-skilling future development involves:
<ul>
<li>
coding to common conventions wherever possible
</li>
<li>
resisting the urge to write clever code
</li>
<li>
rationalising the interest in saving coding work by re-using other software projects that may require niche 
skills or make the code base more likely to become obsolete
</li>
</ul>

<p>
One example of coding to convention is to mark all method parameters in all classes as "final".  Some 
developers advocate adopting this practice to support compiler optimisations, although the benefits seem 
negligible.  Other developers feel the practice adds little value and makes code more cluttered for the 
effort it takes to write "final" in front of every method parameter.
</p>

<p>
My reason for using final method parameters is that it allows me to leverage the power of the compiler to 
spot careless errors I might otherwise overlook when I'm tired.  When a piece of calling code calls a method, 
the actual parameter values the caller passes are copied by reference to the corresponding formal parameters.  
Once this is done, the formal parameters should not be assigned new values.
</p>

<p>
Assigning new references to the formal parameters within the body of the method is considered poor practice.  
But marking method parameters as final increases the chance that this kind of coding mistake can be easily 
detected.    

<p>
The likelihood that I would intentionally assign new values to formal parameters is zero.  But the likelihood 
I would make mistakes after a long session of coding may be significant.  As well, future developers who 
do not keep the consequences of making this mistake in mind may encounter problems and not understand the 
cause of the error.
</p>

<h2>
Coding Philosophy Step 3: Get it working well
</h2>


<h2>
Importance of preferring coding to convention over coding to circumstance in resource poor projects
</h2>






</body>
</html>